# 객체 지향 프로그래밍 

## 절차  지향 프로그래밍 (Procedural Prigramming)

: 프로그램을 '데이터'와 '절차'로 구성하는 방식의 프로그래밍 패러다임

###  특징

- '데이터'와 해당 데이터를 처리하는 '함수(절차)'가 분리되어 있으며, 함수 호출의 흐름이 중요
- 코드의 순차적인 흐름과 함수 호출에 의해 프로그램이 진행
- 실제로 실행되는 내용이 무엇인가가 중요

- 데이터를 다시 재사용하거나 하기보다는 처음부터 끝까지 실행되는 결과물이 중요한 방식



## 소프트웨어의 위기 (Software Crisis)

- 하드웨어의 발전으로 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가함에 따라 소프트웨어에 발생한 충격
- 이에 데이터를 관리하자는 측면에서 객체 지향 프로그래밍 등장



## 객체 지향 프로그래밍 (Object Oriented Programming)

: 데이터와 해당 데이터를 조작하는 메서드를 하나의 객체로 묶어 관리하는 방식의 프로그래밍 패러다임

### 절차 지향 vs 객체 지향

- 절차 지향
  - 데이터와 해당 데이터를처리하는 함수(절차)가 분리 
  - **함수** 호출의 흐름이 중요
- 객체 지향
  - 데이터와 해당 데이터를 저리하는 메서드(메시지)를 하나의 객체(클래스)로 묶음
  - **객체** 간 상호작용과 메시지 전달이 중요



# 객체 (Object)

: 클래스에서 정의한 것을 토대로 메모리에 할당된 것. '속성(변수)'과 '행동(메서드)'으로 구성된 모든 것

- 클래스로 만든 객체를 **인스턴스**라고도 함
  - 아이유는 객체다 (O)
  - 아이유는 인스턴스다 (X)
  - 아이유는 가수의 인스턴스다 (O)
- 클래스를 만든다 == 타입을 만든다

```python
name = 'Alice'

print(type(name))	# <class 'str'>
```

- 변수 name의 타입은 str 클래스
- 변수 name은 **str 클래스의 인스턴스** (문자열 타입(클래스)의 객체(인스턴스))
- 우리가 사용해 왔던 **데이터 타입은 사실 모두 클래스**

```python
'hello',upper()
```

- 문자열.대문자로() → 객체.행동() → **인스턴스.메서드()**
- 함수 중심이 아니라 데이터가 무언가를 행동하는 원리
- **하나의 객체(object)는 특정 타입의 인스턴스(instance)**



### 특징

- 타입(type): 어떤 연산자(operator)와 조작(method)이 가능한가?
- 속성(attribute): 어떤 상태(데이터)를 가지는가?
- 조작법(method): 어떤 행위(함수)를 할 수 있는가?



# 클래스 (Class)

: 파이썬에서 타입을 표현하는 방법

- 객체를 생성하기 위한 설계도
- 데이터와 기능을 함께 묶는 방법을 제공



### 구조

```python
# 클래스 정의
class Person:
    pass

# 인스턴스 생성
iu = Person()

# 메서드 호출
iu.메서드()

#속성(변수) 접근
iu.attribute
```



### 클래스 기본 활용

```python
# 클래스 정의
class Person:
    # 속성(변수)
    blood_color = 'red'

    # 메서드 (개발자가 직접 호출 X)
    def __init__(self, name):   
        self.name = name
        # init: 초기화 (생성자 메서드)
        # 인스턴스를 생성할 때 자동으로 호출됨 (인스턴스가 초기화되어 있어야 하기 때문)
    
    def singing(self):
        return f'{self.name}가 노래합니다.'
        # self.name은 ??
    
# 인스턴스 생성
singer1 = Person('iu')
singer2 = Person('BTS') # 같은 클래스로 만든 다른 인스턴트
# 인스턴스를 만들기 위해서는 인자가 필요
# def __init__(self, name) -> name의 위치 인자

# 메서드 호출 (메서드 사용)
print(singer1.singing())
print(singer2.singing())
# 이 둘은 아무런 관계 없음 (독립적)
# name이 클래스에서 정의되지 않았기 때문

# 속성(변수) 사용
print(singer1.blood_color)
print(singer2.blood_color)
# 결과가 같음. 같은 것을 참조했기 때문
```

- 생성자 함수
  - 객체를 생성할 때 자동으로 호출되는 특별한 메서드
  - _ _ init _ _ 이라는 이름의 메서드로 정의되며, 객체의 초기화를 담당
  - 생성자 함수를 통해 인스턴스를 생성하고 필요한 초기값을 설정
- 인스턴스 변수
  - 인스턴스(객체)마다 별도로 유지되는 변수
  - 인스턴스마다 독립적인 값을 가지며, 인스턴스가 생성될 때마다 초기화 (그 전 인스턴스가 남아 있으면 안 되기 때문)

- 클래스 변수
  - 클래스 내부에 선언된 변수
  - 클래스로 생성된 모든 인스턴스들이 공유하는 변수
- 인스턴스 메서드
  - 각각의 인스턴스에서 호출할 수 있는 메서드
  - 인스턴스 변수에 접근하고 수정하는 등의 작업을 수행



## 인스턴스와 클래스 간의 이름 공간 (namespace)

- 클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
- 인스턴스를 만들면, 인스턴스 객체가 생성되고 독립적인 이름 공간 생성
- 인스턴스에서 특정 속성에 접근하면, 인스턴스 -> 클래스 순으로 탐색



```python
# 인스턴스.메서드()
'abc'.upper()
# '데이터가 무언가를 함': 객체 지향적인 축약형

# 클래스.메서드(인스턴스 자기자신)
str.upper('abc')    # 'upper'는 string 클래스의 소유
# 인스턴스.메서드()는 클래스.메서드(인스턴스 자기자신)의 축약형
# '데이터가 어딘가의 인자로 들어감'

# => 인스턴스 메서드의 첫 번째 매개변수가 반드시 인스턴스 자기 자신인 이유
```



---

- 절차 지향: 데이터와 함수가 분리되어 있다
- 절차 지향적으로 짜여져 있는 코드들은 클래식한 언어들에 해당됨 (대표적으로 C가 있음)

- 객체 지향이 탄생한 이유: 사람의 실제 생각, 현실 세계가 반영되기 위해 탄생
- 절차 지향 - 먹는다(사람), 객체 지향 - 사람.먹는다()
- 과거에는 행동과 행동들이 하는 순서가 중요했다면 지금은 객체가 중요 (인스턴트 중심의 프로그래밍)
- 모든 것은 객체 (클래스도 객체) 그러니까 클래스와 인스턴스로 나눠서 부르자
- 타입을 출력하면 class가 붙었던 이유: 내부적으로 클래스로 형성되어 있기 때문

```python
name = 'harry'
# 'harry' str 클래스의 인스턴스
# name은 str 클래스의 인스턴스
# 'harry'를 더 쉽게 쓰기 위해 name이라는 변수에 담은 것뿐
```



```python
class MakeDict: # make_dict
# 클래스명은 언더바 쓰지 않고 단어 앞을 대문자로 작성
```



```python
class Person:
    # 속성(변수)
    count = 0
    # Person으로 찍어낸 모든 인스턴스들이 공용으로 참조할 수 있음
    
    # 초기값 설정 or 생성하면서 자동으로 실행되는 로직이 있을 때 사용
    def __init__(self, name):	# self: 인스턴스 자기 자신 / name: 초기값
        # pass 초기값이 없으면 pass라도 써서 __init__ 쓰는 게 좋음
    	# name = name	# 이렇게 쓰면 X
        self.name = name
    
    # 메서드
    # 인스턴스 메서드
    def instance_method(self):
    	# 첫 번째 매개변수는 무조건 인스턴스 자기 자신 (self로 표기하는 것은 약속)
    	self.인스턴스변수
    
    # 클래스 메서드
    @classmethod	# 내장된 클래스 데코레이터 / 내부가 어떻게 생겼는지는 중요하지 않음
    def class_method(cls):
        # 첫 번째 매개변수는 이 메서드를 호출하는 클래스
        cls.클래스변수
        cls.클래스메서드
    # 밖으로 빼서 일반 함수로 사용할 수 있지만 코드의 관리 측면에서 클래스 내부에 작성하는 것이 명시적
    
    # 스태틱 메서드
    @staticmethod
    def static_method(a, b):
        # 필수적으로 들어가는 인자는 없음
        return a + b
    
# 인스턴스 생성
인스턴스 = 클래스()
    
# 인스턴스 변수 설정
인스턴스.변수 = 값

# 인스턴스 메서드 사용
인스턴스.인스턴스메서드()
```



- 객체 지향은 절차 지향에서 가지지 못했던 독립성(독립적인 이름 공간)을 가지기 위해 만들어짐
- 객체 지향은 중복되는 코드를 획기적으로 줄일 수 있음
- 인스턴스 변수, 클래스 변수 모두 정의되어 있지 않으면 전역 변수에서 찾음 (전역 변수에도 없으면 error)



```python
class list:
    def append(self, arg):
        # self에 요소 하나를 추가하는 동작

a = [1, 2, 3]	# a와 [1, 2, 3]은 리스트 클래스의 인스턴스

# [1, 2, 3]에 4를 넣으려면?
# 인스턴스.인스턴스메서드
a.append(4)	# 축약형 (이를 파이썬이 제공함) / a가 ~를 한다는 형식 (객체 중심의 코드)

list.append(a, 4) # 위 코드와 같음
```



- 클래스는 모든 메서드 호출 가능하지만 클래스 메서드와 스태틱 메서드만 사용하도록 함
- 인스턴스는 모든 메서드를 호출할 수 있지만 인스턴스 메서드만 사용하도록 함
- 데코레이터: 밑에 작성하는 함수를 인자로 받아서 처리