# 재귀 함수(Recursion function)

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현함
- 따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구성됨
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용함
- 따라서, 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능 저하가 발생함

```python
def f(i, N):	# i: 현재 상태, N: 목표, key
    if i == N:
        print(B)	# [1, 2, 3, 4, 5]
        return
    else:
        B[i] = A[i]
        f(i+1, N)
        
N = 5
A = [1, 2, 3, 4, 5]
B = [0]*N
f(0, N)
```

```python
# key가 있으면 1, 없으면 0을 리턴하는 함수
def f(i, N, key, arr):	# i: 현재 상태, N: 목표, key: 찾고자 하는 원소
    if i == N:
        return 0 	# key가 없는 경우
    elif arr[i] == key:
        return 1
    else:
        f(i+1, N, key, arr)
        
N = 5
A = [1, 2, 3, 4, 5]
key = 3
print(f(0, N, key, A))
```



## 반복과 재귀의 비교

|                    | 재귀                                                     | 반복                  |
| ------------------ | -------------------------------------------------------- | --------------------- |
| **종료**           | 재귀 함수 호출이 종료되는 <br />베이스 케이스(base case) | 반복문의 종료 조건    |
| **수행 시간**      | 상대적 느림                                              | 빠름                  |
| **메모리 공간**    | 상대적 많이 사용                                         | 적게 사용             |
| **소스 코드 길이** | 짧고 간결                                                | 긺                    |
| **소스 코드 형태** | 선택 구조(if...else)                                     | 반복 구조(for, while) |
| **무한 반복 시**   | 스택 오버플로우                                          | CPU를 반복해서 점유   |



## 예시

### 팩토리얼 재귀 함수

#### 재귀적 정의

**Basis rule**

N <= 1 경우, n=1

**Inductive rule**

N > 1, n! = n * (n - 1)!



### 선택 정렬(Selection Sort)의 재귀적 알고리즘

```python
def SelectionSort(n, N, arr):
    # try
```



# 완전 검색 기법

- 완전 검색 방법은 문제의 해법으로 **생각할 수 있는 모든 경우의 수를 나열해보고 확인**하는 기법
- `Brute-force` 혹은 `generate-and-text` 기법이라고도 불림
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용

- 모든 경우의 수를 생성하고 테스트하기 때문에 **수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 적음**
- 평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출
- 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직한 접근



# 순열(Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- nPr : 서로 다른 n개 중 r개를 택하는 순열
  - nPr = n * (n - 1) x (n - 2) x ... x (n - r + 1)
  - nPn = n!

- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있음
  - ex) TSP(Traveling Salesman Problem)
- N개의 요소들에 대해서 n! 개의 순열들이 존재



## 재귀 호출을 통한 순열 생성

```python
# p[]: 데이터가 저장된 배열
# k: 원소의 개수, n: 선택된 원소의 수
perm(i, k)
	if i == k
    	print array		# 원하는 작업 수행
    else
    	for j : i -> k-1
        	p[i] <-> p[j]
            perm(i+1, k)
            p[i] <-> p[j]
```

```python
def f(i, N):	# i: 이전에 고른 개수
    if i == N:  # 순열 완성
        print(p)
        return
    else:   # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:    # 아직 사용되기 전이면
                p[i] = card[j]
                used[j] = 1
                f(i+1, N)
                used[j] = 0


card = [1, 2, 3]
used = [0] * 3  # 이미 사용한 카드인지 표시
p = [0] * 3
f(0, 3)
'''
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
'''
```

```python
# N 개에서 K 개를 고르는 순열
def f(i, N, K):
    global cnt
    if i == K:  # 순열 완성: K 개를 모두 고른 경우
        cnt += 1
        print(cnt, p)
        return
    else:   # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:    # 아직 사용되기 전이면
                p[i] = card[j]
                used[j] = 1
                f(i+1, N, K)
                used[j] = 0


card = [1, 2, 3, 4, 5]
N = 5   # N 개의 숫자에서
K = 3   # K 개를 골라 만드는 순열
used = [0] * N  # 이미 사용한 카드인지 표시
p = [0] * N
cnt = 0
f(0, N, K)
```



# 부분 집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
  - ex) 배낭 짐 싸기(knapsack)
- N개의 원소를 포함한 집합
  - 자기 자신과 공집합 포함한 모든 부분 집합(power set)의 개수는 2^n 개
  - 원소의 수가 증가하면 부분 집합의 개수는 지수적으로 증가



## 부분 집합 생성 방법

### 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)

- 부분 집합을 생성하기 위한 가장 자연스러운 방법
- 바이너리 카운팅(Bibary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법



### 바이너리 카운팅(Binary Counting)

- 원소 수에 해당하는 N개의 비트열을 이용
- n 번째 비트 값이 1이면 n 번째 원소가 포함되었음을 의미

```python
arr = [3, 6, 7, 1, 5, 40]
n = len(arr)

for i in range(1, 1<<(n-1)):	# 1<<n 부분 집합의 개수, 1<<(n-1) == (1<<n)//2
    subset1 = []
    subset2 = []
	for j in range(n):	# 원소의 수만큼 비트를 비교
        if i & (1<<j):	# i의 j 번째 비트가 1이면 j 번째 원소 출력
            subset1.append(arr[j])
        else:
            subset2.append(arr[j])
    print(subset1, subset2)
```



# 조합(combination)

## 구현

### 재귀 호출을 이용한 조합 생성 알고리즘

```python
def ncr(n, r):
    if r == 0:
        print(tr)
    elif n < r:		# 남은 원소보다 많은 원소를 선택해야 하는 경우
        return		# 불가
    else:
        tr[r-1] = a[n-1]	# a[n-1]을 조합에 포함시키는 경우
        ncr(n-1, r-1)
        ncr(n-1, r)			# a[n-1]을 포함시키지 않는 경우

N = 5
R = 3
a = [1, 2, 3, 4, 5]		# an[]: n개의 원소를 가지고 있는 배열
tr = [0]*R				# r개의 크기를 갖는 배열, 조합이 임시 저장될 배열
ncr(N, R)
```



### 10개의 원소 중 3개를 고르는 조합

```python
for i 0 -> 7				# j, k로 선택될 원소를 남김
	for j : i+1 -> 8		# k로 선택될 원소를 남김
    	for k : j+1 -> 0
        	f(a[i], a[j], a[k])
```



### n개에서 r개를 고르는 조합 (재귀)

```python
def nCr(n, r, s):	# n개에서 r개를 고르는 조합, s: 선택할 수 있는 구간의 시작
    if r == 0:
        print(*comb)
    else:
        for i in range(s, n):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)

A = [1, 2, 3, 4, 5]
N = len(A)
R = 2
comb = [0]*R
nCr(N, R, 0)
```



## 연습문제

### 부분집합 합 문제 구현하기

- 아래의 10개의 정수 집합에 대한 모든 부분 집합 중 원소의 합이 0이 되는 부분 집합을 모두 출력
- {-1, 3, -9, 6, 7, -6, 1, 5, 4, -2}

```python
def subset(i, N):
    if i == N:
        s = 0
        for j in range(N):
            if bit[j]:
                s += arr[j]
        if s == 0:
            for j in range(N):
                if bit[j]:
                    print(arr[j], end=' ')
            print()
    else:
        bit[i] = 1
        subset(i+1, N)
        bit[i] = 0
        subset(i+1, N)
    return  # 생략 가능


arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
N = len(arr)
bit = [0]*N
subset(0, N)
```

```python
def subset(i, N, s, c):
    if s == 0 and c!=0:
        return 1
    elif i==N:
        return 0
    else:
        if subset(i+1, N, s+arr[i], c+1):    # arr[i]를 포함했을 때의 합
            return 1
        if subset(i+1, N, s, c):       # 포함하지 않았을 때의 합
            return 1
        return 0


# arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
arr = [1, 2, 3, 4, 5]
N = len(arr)
bit = [0]*N
print(subset(0, N, 0, 0))
```



# 탐욕(Greedy) 알고리즘

- 탐욕 알고리즘은 **최적해를 구하는 데 사용되는 근시안적인 방법**
- 여러 경우 중 하나를 결정해야 할 때마다 그 **순간에 최적이라고 생각되는 것을 선택해 나가는 방식**으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이루어지는 결정은 **지역적으로는 최적**이지만, 그것이 **최종적인 해답으로 적합하다는 보장은 없음**
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 `Greedy`적인 접근



## 동작 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지 확인
   - 즉, 문제의 제약 조건 등을 위반하지 않는지를 검사
3. 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인
   - 아직 전체 문제의 해가 완성되지 않았다면 (1) 의 해 선택부터 다시 시작



## 예시

### 배낭 짐 싸기(Knapsack)

- 도둑은 부자들의 값진 물건들을 훔치기 위해 보관 창고에 침입하였음
- 도둑은 훔친 물건을 배낭에 담아 올 계획 (배낭은 담을 수 있는 물건의 총 무게 W가 정해져 있음)
- 창고에는 여러 개(n개)의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있음
- 경비원들에 발각되기 전에 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건들을 담아야 함



#### Knapsack 문제의 정형적 정의

- S = {item_1, item_2, ..., item_n}, 물건들의 집합
- w_i = item의 무게
- P_i = item_i의 값
- W = 배낭이 수용 가능한 총 무게



#### Knapsack 문제 유형

- 0-1 Knapsack
  - 배낭에 물건을 통째로 담아야 하는 문제
  - 물건을 쪼갤 수 없는 경우
- Fractional Knapsack
  - 물건을 부분적으로 담는 것이 허용되는 문제
  - 물건을 쪼갤 수 있는 경우



#### 0-1 Knapsack에 대한 탐욕적 방법 1

- 값이 비싼 물건부터 채움
- W = 30kg

|       | 무게 | 값     |
| ----- | ---- | ------ |
| 물건1 | 25kg | 10만원 |
| 물건2 | 10kg | 9만원  |
| 물건3 | 10kg | 5만원  |

- 탐욕적 방법의 결과
  - (물건1), 25kg, 10만원
- 최적해
  - (물건2, 물건3), 20kg, 14만원
- 최적해를 구할 수 없음



#### 0-1 Knapsack에 대한 탐욕적 방법 2

- 무게가 가벼운 물건부터 채움
- 탐욕적 방법의 결과
  - (물건2 + 물건3), 14만원
- 최적해
  - (물건1), 15만원
- 최적해를 구할 수 없음



#### 0-1 Knapsack에 대한 탐욕적 방법 3

- 무게 당 값이 높은 순서로 물건을 채움
- 탐욕적 방법
  - (물건1, 물건3), 190만원
- 최적해
  - (물건2, 물건3), 200만원
- 최적해를 구할 수 없음



#### Fractional Knapsack 문제

- 물건의 일부를 잘라서 담을 수 있음
- 탐욕적인 방법
  - (물건1 + 물건3 + 물건2의 절반), 30kg, 220만원



### 회의실 배정하기

- 김대리는 소프트웨어 개발팀들의 회의실 사용 신청을 처리하는 업무를 함. 이번 주 금요일에 사용 가능한 회의실은 하나만 존재하고 다수의 회의가 신청된 상태
- 회의는 시작 시간과 종료 시간이 있으며, 회의 시간이 겹치는 회의들은 동시에 열릴 수 없음
- 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?



#### 활동 선택(Activity-selection problem) 문제

- 시작 시간과 종료 시간(si, fi)이 있는 n개의 활동들의 집합 A = {A1, A2, ..., An}, 1 <= i <=n에서 서로 겹치지 않는 (non-overlapping) 최대 개수의 활동들의 집합 S를 구하는 문제

- 즉, 양립 가능한 활동들의 크기가 최대가 되는 S_(0, n+1)의 부분 집합을 선택하는 문제
  - 종료 시간 순으로 활동들을 정렬
  - S_(0, n+1)는 a_0의 종료 시간부터 a_n+1의 시작 시간 사이에 포함된 활동들
  - S_(0, n+1) = {a1, a2, a3, a4, ... a10}  = S

| i        | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **시작** |      | 1    | 3    | 1    | 5    | 3    | 5    | 6    | 8    | 2    | 12   | ∞    |
| **종료** | 0    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 13   | 14   |      |



#### 탐욕 기법의 적용

- 공집합이 아닌 하위 문제(subproblem) S_i,j가 있고 S_i,j에 속한 활동 a_m은 종료 시간이 가장 빠른 활동

1. 하위 문제 S_i,j에서 **종료 시간이 가장 빠른 활동 a_m을 선택**
2. S_i,m은 공집합이므로, a_m을 선택하면 공집합이 아닌 하위 문제 S_m,j가 남음
3. 1, 2 과정을 반복

<img src="https://i.imgur.com/b1XQeRU.png" alt="img" style="zoom:67%;" />



#### 탐욕 기법을 적용한 반복 알고리즘

- 종료 시간이 빠른 순서로 활동들 정렬
- 첫 번째 활동(A1)을 선택
- 선택한 활동(A1)의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
- 남은 활동들에 대해 앞의 과정 반복

```python
N = 10
a = [1, 4, 1, 6, 6, 10, 5, 7, 3, 8, 5, 9, 3, 5, 8, 11, 2, 13, 12, 14]

meet = []
for i in range(N):
    meet.append([a[i*2], a[i*2+1]])
meet.sort(key=lambda x: x[1])   # 종료 시간 기준으로 정렬
meet = [[0, 0]] + meet  # 첫 번째 활동 추가

S = []
j = 0   # 마지막 활동
for i in range(1, N+1): # N 번 활동까지를 차례대로 선택
    if meet[i][0] >= meet[j][1]:    # si >= fj
        S.append(i)
        j = i

print(S)    #[1, 4, 8, 10]
```



## 탐욕 알고리즘의 필수 요소

- **탐욕적 선택 속성(Greedy choice property)**
  - 탐욕적 선택은 최적해로 갈 수 있음을 보여라
  - 즉, 탐욕적 선택은 항상 안전
- **최적 부분 구조(optimal substructure property)**
  - 최적화 문제를 정형화하라
  - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남음
- **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]** 임을 증명하라



### 탐욕 기법과 동적 계획법의 비교

| 탐욕 기법                                           | 동적 계획법                                          |
| --------------------------------------------------- | ---------------------------------------------------- |
| 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택      | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함 |
| 하위 문제를 풀기 전에 (탐욕적) 선택이 먼저 이루어짐 | 하위 문제가 우선 해결됨                              |
| Top-down 방식                                       | Bottom-up 방식                                       |
| 일반적으로 빠르고 간결                              | 상대적으로 느리고 복잡                               |
